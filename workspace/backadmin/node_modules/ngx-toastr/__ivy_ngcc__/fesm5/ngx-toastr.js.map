{"version":3,"sources":["C:/Users/ASUS/Documents/Work/argon-dashboard-pro-angular-v1.1.1/node_modules/ngx-toastr/fesm5/ngx-toastr.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;SASS;;;;;;;;;2EAMuB;;;;;KAK3B;;;;;;;;;;gDAMwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAsOM,AAE5B;;;;;;;;;kCACkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAoGC,AAEnB;;;;;;;;;kCACS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCA4SgB,AAEzB;;;;;;;;;wIACe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA4M4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAgBpC;;;;;;;;;;;;;;;;;;;;;;;;uBAwBS;;;;;;;;;;;;gDAQF;;;;;;;;;;;;;;;;;;;;MAoBf;;;;;;;;;gDAK4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DA4K2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAMpC;;;;;;;;;;;;;;;;;;;;;;;iCAuBQ;;;;;;;;;;;;gDAQF","file":"ngx-toastr.js","sourcesContent":["import { __decorate, __extends, __param, __assign, __values } from 'tslib';\nimport { ElementRef, Directive, NgModule, InjectionToken, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, ComponentFactoryResolver, ApplicationRef, SecurityContext, Injector, NgZone, INJECTOR, HostBinding, HostListener, Component } from '@angular/core';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { Subject } from 'rxjs';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { DOCUMENT, CommonModule } from '@angular/common';\n\nvar ToastContainerDirective = /** @class */ (function () {\n    function ToastContainerDirective(el) {\n        this.el = el;\n    }\n    ToastContainerDirective.prototype.getContainerElement = function () {\n        return this.el.nativeElement;\n    };\n    ToastContainerDirective.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    ToastContainerDirective = __decorate([\n        Directive({\n            selector: '[toastContainer]',\n            exportAs: 'toastContainer',\n        })\n    ], ToastContainerDirective);\n    return ToastContainerDirective;\n}());\nvar ToastContainerModule = /** @class */ (function () {\n    function ToastContainerModule() {\n    }\n    ToastContainerModule = __decorate([\n        NgModule({\n            declarations: [ToastContainerDirective],\n            exports: [ToastContainerDirective],\n        })\n    ], ToastContainerModule);\n    return ToastContainerModule;\n}());\n\n/**\n * Everything a toast needs to launch\n */\nvar ToastPackage = /** @class */ (function () {\n    function ToastPackage(toastId, config, message, title, toastType, toastRef) {\n        var _this = this;\n        this.toastId = toastId;\n        this.config = config;\n        this.message = message;\n        this.title = title;\n        this.toastType = toastType;\n        this.toastRef = toastRef;\n        this._onTap = new Subject();\n        this._onAction = new Subject();\n        this.toastRef.afterClosed().subscribe(function () {\n            _this._onAction.complete();\n            _this._onTap.complete();\n        });\n    }\n    /** Fired on click */\n    ToastPackage.prototype.triggerTap = function () {\n        this._onTap.next();\n        if (this.config.tapToDismiss) {\n            this._onTap.complete();\n        }\n    };\n    ToastPackage.prototype.onTap = function () {\n        return this._onTap.asObservable();\n    };\n    /** available for use in custom toast */\n    ToastPackage.prototype.triggerAction = function (action) {\n        this._onAction.next(action);\n    };\n    ToastPackage.prototype.onAction = function () {\n        return this._onAction.asObservable();\n    };\n    return ToastPackage;\n}());\nvar DefaultNoComponentGlobalConfig = {\n    maxOpened: 0,\n    autoDismiss: false,\n    newestOnTop: true,\n    preventDuplicates: false,\n    countDuplicates: false,\n    resetTimeoutOnDuplicate: false,\n    iconClasses: {\n        error: 'toast-error',\n        info: 'toast-info',\n        success: 'toast-success',\n        warning: 'toast-warning',\n    },\n    // Individual\n    closeButton: false,\n    disableTimeOut: false,\n    timeOut: 5000,\n    extendedTimeOut: 1000,\n    enableHtml: false,\n    progressBar: false,\n    toastClass: 'ngx-toastr',\n    positionClass: 'toast-top-right',\n    titleClass: 'toast-title',\n    messageClass: 'toast-message',\n    easing: 'ease-in',\n    easeTime: 300,\n    tapToDismiss: true,\n    onActivateTick: false,\n    progressAnimation: 'decreasing',\n};\nvar TOAST_CONFIG = new InjectionToken('ToastConfig');\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = /** @class */ (function () {\n    function ComponentPortal(component, injector) {\n        this.component = component;\n        this.injector = injector;\n    }\n    /** Attach this portal to a host. */\n    ComponentPortal.prototype.attach = function (host, newestOnTop) {\n        this._attachedHost = host;\n        return host.attach(this, newestOnTop);\n    };\n    /** Detach this portal from its host */\n    ComponentPortal.prototype.detach = function () {\n        var host = this._attachedHost;\n        if (host) {\n            this._attachedHost = undefined;\n            return host.detach();\n        }\n    };\n    Object.defineProperty(ComponentPortal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detach()`.\n     */\n    ComponentPortal.prototype.setAttachedHost = function (host) {\n        this._attachedHost = host;\n    };\n    return ComponentPortal;\n}());\n/**\n * Partial implementation of PortalHost that only deals with attaching a\n * ComponentPortal\n */\nvar BasePortalHost = /** @class */ (function () {\n    function BasePortalHost() {\n    }\n    BasePortalHost.prototype.attach = function (portal, newestOnTop) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal, newestOnTop);\n    };\n    BasePortalHost.prototype.detach = function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost();\n        }\n        this._attachedPortal = undefined;\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = undefined;\n        }\n    };\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\n        this._disposeFn = fn;\n    };\n    return BasePortalHost;\n}());\n\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar DomPortalHost = /** @class */ (function (_super) {\n    __extends(DomPortalHost, _super);\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     */\n    DomPortalHost.prototype.attachComponentPortal = function (portal, newestOnTop) {\n        var _this = this;\n        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the ChangeDetector for that component to the application (which\n        // happens automatically when using a ViewContainer).\n        componentRef = componentFactory.create(portal.injector);\n        // When creating a component outside of a ViewContainer, we need to manually register\n        // its ChangeDetector with the application. This API is unfortunately not yet published\n        // in Angular core. The change detector must also be deregistered when the component\n        // is destroyed to prevent memory leaks.\n        this._appRef.attachView(componentRef.hostView);\n        this.setDisposeFn(function () {\n            _this._appRef.detachView(componentRef.hostView);\n            componentRef.destroy();\n        });\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        if (newestOnTop) {\n            this._hostDomElement.insertBefore(this._getComponentRootNode(componentRef), this._hostDomElement.firstChild);\n        }\n        else {\n            this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        }\n        return componentRef;\n    };\n    /** Gets the root HTMLElement for an instantiated component. */\n    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    };\n    return DomPortalHost;\n}(BasePortalHost));\n\n/** Container inside which all toasts will render. */\nvar OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    OverlayContainer.prototype.ngOnDestroy = function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    OverlayContainer.prototype.getContainerElement = function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    OverlayContainer.prototype._createContainer = function () {\n        var container = this._document.createElement('div');\n        container.classList.add('overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    OverlayContainer.ɵprov = ɵɵdefineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(ɵɵinject(DOCUMENT)); }, token: OverlayContainer, providedIn: \"root\" });\n    OverlayContainer = __decorate([\n        Injectable({ providedIn: 'root' }),\n        __param(0, Inject(DOCUMENT))\n    ], OverlayContainer);\n    return OverlayContainer;\n}());\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalHost) {\n        this._portalHost = _portalHost;\n    }\n    OverlayRef.prototype.attach = function (portal, newestOnTop) {\n        if (newestOnTop === void 0) { newestOnTop = true; }\n        return this._portalHost.attach(portal, newestOnTop);\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns Resolves when the overlay has been detached.\n     */\n    OverlayRef.prototype.detach = function () {\n        return this._portalHost.detach();\n    };\n    return OverlayRef;\n}());\n\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ (function () {\n    function Overlay(_overlayContainer, _componentFactoryResolver, _appRef, _document) {\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._document = _document;\n        // Namespace panes by overlay container\n        this._paneElements = new Map();\n    }\n    /**\n     * Creates an overlay.\n     * @returns A reference to the created overlay.\n     */\n    Overlay.prototype.create = function (positionClass, overlayContainer) {\n        // get existing pane if possible\n        return this._createOverlayRef(this.getPaneElement(positionClass, overlayContainer));\n    };\n    Overlay.prototype.getPaneElement = function (positionClass, overlayContainer) {\n        if (positionClass === void 0) { positionClass = ''; }\n        if (!this._paneElements.get(overlayContainer)) {\n            this._paneElements.set(overlayContainer, {});\n        }\n        if (!this._paneElements.get(overlayContainer)[positionClass]) {\n            this._paneElements.get(overlayContainer)[positionClass] = this._createPaneElement(positionClass, overlayContainer);\n        }\n        return this._paneElements.get(overlayContainer)[positionClass];\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = function (positionClass, overlayContainer) {\n        var pane = this._document.createElement('div');\n        pane.id = 'toast-container';\n        pane.classList.add(positionClass);\n        pane.classList.add('toast-container');\n        if (!overlayContainer) {\n            this._overlayContainer.getContainerElement().appendChild(pane);\n        }\n        else {\n            overlayContainer.getContainerElement().appendChild(pane);\n        }\n        return pane;\n    };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal host.\n     * @returns A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = function (pane) {\n        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef);\n    };\n    /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @param pane DOM element for the overlay\n     */\n    Overlay.prototype._createOverlayRef = function (pane) {\n        return new OverlayRef(this._createPortalHost(pane));\n    };\n    Overlay.ctorParameters = function () { return [\n        { type: OverlayContainer },\n        { type: ComponentFactoryResolver },\n        { type: ApplicationRef },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    Overlay.ɵprov = ɵɵdefineInjectable({ factory: function Overlay_Factory() { return new Overlay(ɵɵinject(OverlayContainer), ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(DOCUMENT)); }, token: Overlay, providedIn: \"root\" });\n    Overlay = __decorate([\n        Injectable({ providedIn: 'root' }),\n        __param(3, Inject(DOCUMENT))\n    ], Overlay);\n    return Overlay;\n}());\n\n/**\n * Reference to a toast opened via the Toastr service.\n */\nvar ToastRef = /** @class */ (function () {\n    function ToastRef(_overlayRef) {\n        this._overlayRef = _overlayRef;\n        /** Count of duplicates of this toast */\n        this.duplicatesCount = 0;\n        /** Subject for notifying the user that the toast has finished closing. */\n        this._afterClosed = new Subject();\n        /** triggered when toast is activated */\n        this._activate = new Subject();\n        /** notifies the toast that it should close before the timeout */\n        this._manualClose = new Subject();\n        /** notifies the toast that it should reset the timeouts */\n        this._resetTimeout = new Subject();\n        /** notifies the toast that it should count a duplicate toast */\n        this._countDuplicate = new Subject();\n    }\n    ToastRef.prototype.manualClose = function () {\n        this._manualClose.next();\n        this._manualClose.complete();\n    };\n    ToastRef.prototype.manualClosed = function () {\n        return this._manualClose.asObservable();\n    };\n    ToastRef.prototype.timeoutReset = function () {\n        return this._resetTimeout.asObservable();\n    };\n    ToastRef.prototype.countDuplicate = function () {\n        return this._countDuplicate.asObservable();\n    };\n    /**\n     * Close the toast.\n     */\n    ToastRef.prototype.close = function () {\n        this._overlayRef.detach();\n        this._afterClosed.next();\n        this._manualClose.next();\n        this._afterClosed.complete();\n        this._manualClose.complete();\n        this._activate.complete();\n        this._resetTimeout.complete();\n        this._countDuplicate.complete();\n    };\n    /** Gets an observable that is notified when the toast is finished closing. */\n    ToastRef.prototype.afterClosed = function () {\n        return this._afterClosed.asObservable();\n    };\n    ToastRef.prototype.isInactive = function () {\n        return this._activate.isStopped;\n    };\n    ToastRef.prototype.activate = function () {\n        this._activate.next();\n        this._activate.complete();\n    };\n    /** Gets an observable that is notified when the toast has started opening. */\n    ToastRef.prototype.afterActivate = function () {\n        return this._activate.asObservable();\n    };\n    /** Reset the toast timouts and count duplicates */\n    ToastRef.prototype.onDuplicate = function (resetTimeout, countDuplicate) {\n        if (resetTimeout) {\n            this._resetTimeout.next();\n        }\n        if (countDuplicate) {\n            this._countDuplicate.next(++this.duplicatesCount);\n        }\n    };\n    return ToastRef;\n}());\n/** Custom injector type specifically for instantiating components with a toast. */\nvar ToastInjector = /** @class */ (function () {\n    function ToastInjector(_toastPackage, _parentInjector) {\n        this._toastPackage = _toastPackage;\n        this._parentInjector = _parentInjector;\n    }\n    ToastInjector.prototype.get = function (token, notFoundValue, flags) {\n        if (token === ToastPackage) {\n            return this._toastPackage;\n        }\n        return this._parentInjector.get(token, notFoundValue, flags);\n    };\n    return ToastInjector;\n}());\n\nvar ToastrService = /** @class */ (function () {\n    function ToastrService(token, overlay, _injector, sanitizer, ngZone) {\n        this.overlay = overlay;\n        this._injector = _injector;\n        this.sanitizer = sanitizer;\n        this.ngZone = ngZone;\n        this.currentlyActive = 0;\n        this.toasts = [];\n        this.index = 0;\n        this.toastrConfig = __assign(__assign({}, token.default), token.config);\n        if (token.config.iconClasses) {\n            this.toastrConfig.iconClasses = __assign(__assign({}, token.default.iconClasses), token.config.iconClasses);\n        }\n    }\n    /** show toast */\n    ToastrService.prototype.show = function (message, title, override, type) {\n        if (override === void 0) { override = {}; }\n        if (type === void 0) { type = ''; }\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /** show successful toast */\n    ToastrService.prototype.success = function (message, title, override) {\n        if (override === void 0) { override = {}; }\n        var type = this.toastrConfig.iconClasses.success || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /** show error toast */\n    ToastrService.prototype.error = function (message, title, override) {\n        if (override === void 0) { override = {}; }\n        var type = this.toastrConfig.iconClasses.error || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /** show info toast */\n    ToastrService.prototype.info = function (message, title, override) {\n        if (override === void 0) { override = {}; }\n        var type = this.toastrConfig.iconClasses.info || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /** show warning toast */\n    ToastrService.prototype.warning = function (message, title, override) {\n        if (override === void 0) { override = {}; }\n        var type = this.toastrConfig.iconClasses.warning || '';\n        return this._preBuildNotification(type, message, title, this.applyConfig(override));\n    };\n    /**\n     * Remove all or a single toast by id\n     */\n    ToastrService.prototype.clear = function (toastId) {\n        var e_1, _a;\n        try {\n            // Call every toastRef manualClose function\n            for (var _b = __values(this.toasts), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var toast = _c.value;\n                if (toastId !== undefined) {\n                    if (toast.toastId === toastId) {\n                        toast.toastRef.manualClose();\n                        return;\n                    }\n                }\n                else {\n                    toast.toastRef.manualClose();\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Remove and destroy a single toast by id\n     */\n    ToastrService.prototype.remove = function (toastId) {\n        var found = this._findToast(toastId);\n        if (!found) {\n            return false;\n        }\n        found.activeToast.toastRef.close();\n        this.toasts.splice(found.index, 1);\n        this.currentlyActive = this.currentlyActive - 1;\n        if (!this.toastrConfig.maxOpened || !this.toasts.length) {\n            return false;\n        }\n        if (this.currentlyActive < this.toastrConfig.maxOpened &&\n            this.toasts[this.currentlyActive]) {\n            var p = this.toasts[this.currentlyActive].toastRef;\n            if (!p.isInactive()) {\n                this.currentlyActive = this.currentlyActive + 1;\n                p.activate();\n            }\n        }\n        return true;\n    };\n    /**\n     * Determines if toast message is already shown\n     */\n    ToastrService.prototype.findDuplicate = function (message, resetOnDuplicate, countDuplicates) {\n        var e_2, _a;\n        try {\n            for (var _b = __values(this.toasts), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var toast = _c.value;\n                if (toast.message === message) {\n                    toast.toastRef.onDuplicate(resetOnDuplicate, countDuplicates);\n                    return toast;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return null;\n    };\n    /** create a clone of global config and apply individual settings */\n    ToastrService.prototype.applyConfig = function (override) {\n        if (override === void 0) { override = {}; }\n        return __assign(__assign({}, this.toastrConfig), override);\n    };\n    /**\n     * Find toast object by id\n     */\n    ToastrService.prototype._findToast = function (toastId) {\n        for (var i = 0; i < this.toasts.length; i++) {\n            if (this.toasts[i].toastId === toastId) {\n                return { index: i, activeToast: this.toasts[i] };\n            }\n        }\n        return null;\n    };\n    /**\n     * Determines the need to run inside angular's zone then builds the toast\n     */\n    ToastrService.prototype._preBuildNotification = function (toastType, message, title, config) {\n        var _this = this;\n        if (config.onActivateTick) {\n            return this.ngZone.run(function () {\n                return _this._buildNotification(toastType, message, title, config);\n            });\n        }\n        return this._buildNotification(toastType, message, title, config);\n    };\n    /**\n     * Creates and attaches toast data to component\n     * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.\n     */\n    ToastrService.prototype._buildNotification = function (toastType, message, title, config) {\n        if (!config.toastComponent) {\n            throw new Error('toastComponent required');\n        }\n        // max opened and auto dismiss = true\n        // if timeout = 0 resetting it would result in setting this.hideTime = Date.now(). Hence, we only want to reset timeout if there is\n        // a timeout at all\n        var duplicate = this.findDuplicate(message, this.toastrConfig.resetTimeoutOnDuplicate && config.timeOut > 0, this.toastrConfig.countDuplicates);\n        if (message && this.toastrConfig.preventDuplicates && duplicate !== null) {\n            return duplicate;\n        }\n        this.previousToastMessage = message;\n        var keepInactive = false;\n        if (this.toastrConfig.maxOpened &&\n            this.currentlyActive >= this.toastrConfig.maxOpened) {\n            keepInactive = true;\n            if (this.toastrConfig.autoDismiss) {\n                this.clear(this.toasts[0].toastId);\n            }\n        }\n        var overlayRef = this.overlay.create(config.positionClass, this.overlayContainer);\n        this.index = this.index + 1;\n        var sanitizedMessage = message;\n        if (message && config.enableHtml) {\n            sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);\n        }\n        var toastRef = new ToastRef(overlayRef);\n        var toastPackage = new ToastPackage(this.index, config, sanitizedMessage, title, toastType, toastRef);\n        var toastInjector = new ToastInjector(toastPackage, this._injector);\n        var component = new ComponentPortal(config.toastComponent, toastInjector);\n        var portal = overlayRef.attach(component, this.toastrConfig.newestOnTop);\n        toastRef.componentInstance = portal.instance;\n        var ins = {\n            toastId: this.index,\n            message: message || '',\n            toastRef: toastRef,\n            onShown: toastRef.afterActivate(),\n            onHidden: toastRef.afterClosed(),\n            onTap: toastPackage.onTap(),\n            onAction: toastPackage.onAction(),\n            portal: portal\n        };\n        if (!keepInactive) {\n            this.currentlyActive = this.currentlyActive + 1;\n            setTimeout(function () {\n                ins.toastRef.activate();\n            });\n        }\n        this.toasts.push(ins);\n        return ins;\n    };\n    ToastrService.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [TOAST_CONFIG,] }] },\n        { type: Overlay },\n        { type: Injector },\n        { type: DomSanitizer },\n        { type: NgZone }\n    ]; };\n    ToastrService.ɵprov = ɵɵdefineInjectable({ factory: function ToastrService_Factory() { return new ToastrService(ɵɵinject(TOAST_CONFIG), ɵɵinject(Overlay), ɵɵinject(INJECTOR), ɵɵinject(DomSanitizer), ɵɵinject(NgZone)); }, token: ToastrService, providedIn: \"root\" });\n    ToastrService = __decorate([\n        Injectable({ providedIn: 'root' }),\n        __param(0, Inject(TOAST_CONFIG))\n    ], ToastrService);\n    return ToastrService;\n}());\n\nvar Toast = /** @class */ (function () {\n    function Toast(toastrService, toastPackage, ngZone) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.ngZone = ngZone;\n        /** width of progress bar */\n        this.width = -1;\n        /** a combination of toast type and options.toastClass */\n        this.toastClasses = '';\n        /** controls animation */\n        this.state = {\n            value: 'inactive',\n            params: {\n                easeTime: this.toastPackage.config.easeTime,\n                easing: 'ease-in'\n            }\n        };\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.originalTimeout = toastPackage.config.timeOut;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(function () {\n            _this.activateToast();\n        });\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(function () {\n            _this.remove();\n        });\n        this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(function () {\n            _this.resetTimeout();\n        });\n        this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(function (count) {\n            _this.duplicatesCount = count;\n        });\n    }\n    Object.defineProperty(Toast.prototype, \"displayStyle\", {\n        /** hides component when waiting to be displayed */\n        get: function () {\n            if (this.state.value === 'inactive') {\n                return 'none';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Toast.prototype.ngOnDestroy = function () {\n        this.sub.unsubscribe();\n        this.sub1.unsubscribe();\n        this.sub2.unsubscribe();\n        this.sub3.unsubscribe();\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeout);\n    };\n    /**\n     * activates toast and sets timeout\n     */\n    Toast.prototype.activateToast = function () {\n        var _this = this;\n        this.state = __assign(__assign({}, this.state), { value: 'active' });\n        if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === 'timeOut') && this.options.timeOut) {\n            this.outsideTimeout(function () { return _this.remove(); }, this.options.timeOut);\n            this.hideTime = new Date().getTime() + this.options.timeOut;\n            if (this.options.progressBar) {\n                this.outsideInterval(function () { return _this.updateProgress(); }, 10);\n            }\n        }\n    };\n    /**\n     * updates progress bar width\n     */\n    Toast.prototype.updateProgress = function () {\n        if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n            return;\n        }\n        var now = new Date().getTime();\n        var remaining = this.hideTime - now;\n        this.width = (remaining / this.options.timeOut) * 100;\n        if (this.options.progressAnimation === 'increasing') {\n            this.width = 100 - this.width;\n        }\n        if (this.width <= 0) {\n            this.width = 0;\n        }\n        if (this.width >= 100) {\n            this.width = 100;\n        }\n    };\n    Toast.prototype.resetTimeout = function () {\n        var _this = this;\n        clearTimeout(this.timeout);\n        clearInterval(this.intervalId);\n        this.state = __assign(__assign({}, this.state), { value: 'active' });\n        this.outsideTimeout(function () { return _this.remove(); }, this.originalTimeout);\n        this.options.timeOut = this.originalTimeout;\n        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.outsideInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    /**\n     * tells toastrService to remove this toast after animation time\n     */\n    Toast.prototype.remove = function () {\n        var _this = this;\n        if (this.state.value === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.state = __assign(__assign({}, this.state), { value: 'removed' });\n        this.outsideTimeout(function () { return _this.toastrService.remove(_this.toastPackage.toastId); }, +this.toastPackage.config.easeTime);\n    };\n    Toast.prototype.tapToast = function () {\n        if (this.state.value === 'removed') {\n            return;\n        }\n        this.toastPackage.triggerTap();\n        if (this.options.tapToDismiss) {\n            this.remove();\n        }\n    };\n    Toast.prototype.stickAround = function () {\n        if (this.state.value === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.options.timeOut = 0;\n        this.hideTime = 0;\n        // disable progressBar\n        clearInterval(this.intervalId);\n        this.width = 0;\n    };\n    Toast.prototype.delayedHideToast = function () {\n        var _this = this;\n        if ((this.options.disableTimeOut === true || this.options.disableTimeOut === 'extendedTimeOut') ||\n            this.options.extendedTimeOut === 0 ||\n            this.state.value === 'removed') {\n            return;\n        }\n        this.outsideTimeout(function () { return _this.remove(); }, this.options.extendedTimeOut);\n        this.options.timeOut = this.options.extendedTimeOut;\n        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.outsideInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    Toast.prototype.outsideTimeout = function (func, timeout) {\n        var _this = this;\n        if (this.ngZone) {\n            this.ngZone.runOutsideAngular(function () {\n                return (_this.timeout = setTimeout(function () { return _this.runInsideAngular(func); }, timeout));\n            });\n        }\n        else {\n            this.timeout = setTimeout(function () { return func(); }, timeout);\n        }\n    };\n    Toast.prototype.outsideInterval = function (func, timeout) {\n        var _this = this;\n        if (this.ngZone) {\n            this.ngZone.runOutsideAngular(function () {\n                return (_this.intervalId = setInterval(function () { return _this.runInsideAngular(func); }, timeout));\n            });\n        }\n        else {\n            this.intervalId = setInterval(function () { return func(); }, timeout);\n        }\n    };\n    Toast.prototype.runInsideAngular = function (func) {\n        if (this.ngZone) {\n            this.ngZone.run(function () { return func(); });\n        }\n        else {\n            func();\n        }\n    };\n    Toast.ctorParameters = function () { return [\n        { type: ToastrService },\n        { type: ToastPackage },\n        { type: NgZone }\n    ]; };\n    __decorate([\n        HostBinding('class')\n    ], Toast.prototype, \"toastClasses\", void 0);\n    __decorate([\n        HostBinding('@flyInOut')\n    ], Toast.prototype, \"state\", void 0);\n    __decorate([\n        HostBinding('style.display')\n    ], Toast.prototype, \"displayStyle\", null);\n    __decorate([\n        HostListener('click')\n    ], Toast.prototype, \"tapToast\", null);\n    __decorate([\n        HostListener('mouseenter')\n    ], Toast.prototype, \"stickAround\", null);\n    __decorate([\n        HostListener('mouseleave')\n    ], Toast.prototype, \"delayedHideToast\", null);\n    Toast = __decorate([\n        Component({\n            selector: '[toast-component]',\n            template: \"\\n  <button *ngIf=\\\"options.closeButton\\\" (click)=\\\"remove()\\\" class=\\\"toast-close-button\\\" aria-label=\\\"Close\\\">\\n    <span aria-hidden=\\\"true\\\">&times;</span>\\n  </button>\\n  <div *ngIf=\\\"title\\\" [class]=\\\"options.titleClass\\\" [attr.aria-label]=\\\"title\\\">\\n    {{ title }} <ng-container *ngIf=\\\"duplicatesCount\\\">[{{ duplicatesCount + 1 }}]</ng-container>\\n  </div>\\n  <div *ngIf=\\\"message && options.enableHtml\\\" role=\\\"alertdialog\\\" aria-live=\\\"polite\\\"\\n    [class]=\\\"options.messageClass\\\" [innerHTML]=\\\"message\\\">\\n  </div>\\n  <div *ngIf=\\\"message && !options.enableHtml\\\" role=\\\"alertdialog\\\" aria-live=\\\"polite\\\"\\n    [class]=\\\"options.messageClass\\\" [attr.aria-label]=\\\"message\\\">\\n    {{ message }}\\n  </div>\\n  <div *ngIf=\\\"options.progressBar\\\">\\n    <div class=\\\"toast-progress\\\" [style.width]=\\\"width + '%'\\\"></div>\\n  </div>\\n  \",\n            animations: [\n                trigger('flyInOut', [\n                    state('inactive', style({ opacity: 0 })),\n                    state('active', style({ opacity: 1 })),\n                    state('removed', style({ opacity: 0 })),\n                    transition('inactive => active', animate('{{ easeTime }}ms {{ easing }}')),\n                    transition('active => removed', animate('{{ easeTime }}ms {{ easing }}'))\n                ])\n            ],\n            preserveWhitespaces: false\n        })\n    ], Toast);\n    return Toast;\n}());\n\nvar DefaultGlobalConfig = __assign(__assign({}, DefaultNoComponentGlobalConfig), { toastComponent: Toast });\nvar ToastrModule = /** @class */ (function () {\n    function ToastrModule() {\n    }\n    ToastrModule_1 = ToastrModule;\n    ToastrModule.forRoot = function (config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: ToastrModule_1,\n            providers: [\n                {\n                    provide: TOAST_CONFIG,\n                    useValue: {\n                        default: DefaultGlobalConfig,\n                        config: config,\n                    },\n                },\n            ],\n        };\n    };\n    var ToastrModule_1;\n    ToastrModule = ToastrModule_1 = __decorate([\n        NgModule({\n            imports: [CommonModule],\n            declarations: [Toast],\n            exports: [Toast],\n            entryComponents: [Toast],\n        })\n    ], ToastrModule);\n    return ToastrModule;\n}());\nvar ToastrComponentlessModule = /** @class */ (function () {\n    function ToastrComponentlessModule() {\n    }\n    ToastrComponentlessModule.forRoot = function (config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: ToastrModule,\n            providers: [\n                {\n                    provide: TOAST_CONFIG,\n                    useValue: {\n                        default: DefaultNoComponentGlobalConfig,\n                        config: config,\n                    },\n                },\n            ],\n        };\n    };\n    ToastrComponentlessModule = __decorate([\n        NgModule({\n            imports: [CommonModule],\n        })\n    ], ToastrComponentlessModule);\n    return ToastrComponentlessModule;\n}());\n\nvar ToastNoAnimation = /** @class */ (function () {\n    function ToastNoAnimation(toastrService, toastPackage, appRef) {\n        var _this = this;\n        this.toastrService = toastrService;\n        this.toastPackage = toastPackage;\n        this.appRef = appRef;\n        /** width of progress bar */\n        this.width = -1;\n        /** a combination of toast type and options.toastClass */\n        this.toastClasses = '';\n        /** controls animation */\n        this.state = 'inactive';\n        this.message = toastPackage.message;\n        this.title = toastPackage.title;\n        this.options = toastPackage.config;\n        this.originalTimeout = toastPackage.config.timeOut;\n        this.toastClasses = toastPackage.toastType + \" \" + toastPackage.config.toastClass;\n        this.sub = toastPackage.toastRef.afterActivate().subscribe(function () {\n            _this.activateToast();\n        });\n        this.sub1 = toastPackage.toastRef.manualClosed().subscribe(function () {\n            _this.remove();\n        });\n        this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(function () {\n            _this.resetTimeout();\n        });\n        this.sub3 = toastPackage.toastRef.countDuplicate().subscribe(function (count) {\n            _this.duplicatesCount = count;\n        });\n    }\n    Object.defineProperty(ToastNoAnimation.prototype, \"displayStyle\", {\n        /** hides component when waiting to be displayed */\n        get: function () {\n            if (this.state === 'inactive') {\n                return 'none';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ToastNoAnimation.prototype.ngOnDestroy = function () {\n        this.sub.unsubscribe();\n        this.sub1.unsubscribe();\n        this.sub2.unsubscribe();\n        this.sub3.unsubscribe();\n        clearInterval(this.intervalId);\n        clearTimeout(this.timeout);\n    };\n    /**\n     * activates toast and sets timeout\n     */\n    ToastNoAnimation.prototype.activateToast = function () {\n        var _this = this;\n        this.state = 'active';\n        if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === 'timeOut') && this.options.timeOut) {\n            this.timeout = setTimeout(function () {\n                _this.remove();\n            }, this.options.timeOut);\n            this.hideTime = new Date().getTime() + this.options.timeOut;\n            if (this.options.progressBar) {\n                this.intervalId = setInterval(function () { return _this.updateProgress(); }, 10);\n            }\n        }\n        if (this.options.onActivateTick) {\n            this.appRef.tick();\n        }\n    };\n    /**\n     * updates progress bar width\n     */\n    ToastNoAnimation.prototype.updateProgress = function () {\n        if (this.width === 0 || this.width === 100 || !this.options.timeOut) {\n            return;\n        }\n        var now = new Date().getTime();\n        var remaining = this.hideTime - now;\n        this.width = (remaining / this.options.timeOut) * 100;\n        if (this.options.progressAnimation === 'increasing') {\n            this.width = 100 - this.width;\n        }\n        if (this.width <= 0) {\n            this.width = 0;\n        }\n        if (this.width >= 100) {\n            this.width = 100;\n        }\n    };\n    ToastNoAnimation.prototype.resetTimeout = function () {\n        var _this = this;\n        clearTimeout(this.timeout);\n        clearInterval(this.intervalId);\n        this.state = 'active';\n        this.options.timeOut = this.originalTimeout;\n        this.timeout = setTimeout(function () { return _this.remove(); }, this.originalTimeout);\n        this.hideTime = new Date().getTime() + (this.originalTimeout || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.intervalId = setInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    /**\n     * tells toastrService to remove this toast after animation time\n     */\n    ToastNoAnimation.prototype.remove = function () {\n        var _this = this;\n        if (this.state === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.state = 'removed';\n        this.timeout = setTimeout(function () {\n            return _this.toastrService.remove(_this.toastPackage.toastId);\n        });\n    };\n    ToastNoAnimation.prototype.tapToast = function () {\n        if (this.state === 'removed') {\n            return;\n        }\n        this.toastPackage.triggerTap();\n        if (this.options.tapToDismiss) {\n            this.remove();\n        }\n    };\n    ToastNoAnimation.prototype.stickAround = function () {\n        if (this.state === 'removed') {\n            return;\n        }\n        clearTimeout(this.timeout);\n        this.options.timeOut = 0;\n        this.hideTime = 0;\n        // disable progressBar\n        clearInterval(this.intervalId);\n        this.width = 0;\n    };\n    ToastNoAnimation.prototype.delayedHideToast = function () {\n        var _this = this;\n        if ((this.options.disableTimeOut === true || this.options.disableTimeOut === 'extendedTimeOut') ||\n            this.options.extendedTimeOut === 0 ||\n            this.state === 'removed') {\n            return;\n        }\n        this.timeout = setTimeout(function () { return _this.remove(); }, this.options.extendedTimeOut);\n        this.options.timeOut = this.options.extendedTimeOut;\n        this.hideTime = new Date().getTime() + (this.options.timeOut || 0);\n        this.width = -1;\n        if (this.options.progressBar) {\n            this.intervalId = setInterval(function () { return _this.updateProgress(); }, 10);\n        }\n    };\n    ToastNoAnimation.ctorParameters = function () { return [\n        { type: ToastrService },\n        { type: ToastPackage },\n        { type: ApplicationRef }\n    ]; };\n    __decorate([\n        HostBinding('class')\n    ], ToastNoAnimation.prototype, \"toastClasses\", void 0);\n    __decorate([\n        HostBinding('style.display')\n    ], ToastNoAnimation.prototype, \"displayStyle\", null);\n    __decorate([\n        HostListener('click')\n    ], ToastNoAnimation.prototype, \"tapToast\", null);\n    __decorate([\n        HostListener('mouseenter')\n    ], ToastNoAnimation.prototype, \"stickAround\", null);\n    __decorate([\n        HostListener('mouseleave')\n    ], ToastNoAnimation.prototype, \"delayedHideToast\", null);\n    ToastNoAnimation = __decorate([\n        Component({\n            selector: '[toast-component]',\n            template: \"\\n  <button *ngIf=\\\"options.closeButton\\\" (click)=\\\"remove()\\\" class=\\\"toast-close-button\\\" aria-label=\\\"Close\\\">\\n    <span aria-hidden=\\\"true\\\">&times;</span>\\n  </button>\\n  <div *ngIf=\\\"title\\\" [class]=\\\"options.titleClass\\\" [attr.aria-label]=\\\"title\\\">\\n    {{ title }} <ng-container *ngIf=\\\"duplicatesCount\\\">[{{ duplicatesCount + 1 }}]</ng-container>\\n  </div>\\n  <div *ngIf=\\\"message && options.enableHtml\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\"\\n    [class]=\\\"options.messageClass\\\" [innerHTML]=\\\"message\\\">\\n  </div>\\n  <div *ngIf=\\\"message && !options.enableHtml\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\"\\n    [class]=\\\"options.messageClass\\\" [attr.aria-label]=\\\"message\\\">\\n    {{ message }}\\n  </div>\\n  <div *ngIf=\\\"options.progressBar\\\">\\n    <div class=\\\"toast-progress\\\" [style.width]=\\\"width + '%'\\\"></div>\\n  </div>\\n  \"\n        })\n    ], ToastNoAnimation);\n    return ToastNoAnimation;\n}());\nvar DefaultNoAnimationsGlobalConfig = __assign(__assign({}, DefaultNoComponentGlobalConfig), { toastComponent: ToastNoAnimation });\nvar ToastNoAnimationModule = /** @class */ (function () {\n    function ToastNoAnimationModule() {\n    }\n    ToastNoAnimationModule_1 = ToastNoAnimationModule;\n    ToastNoAnimationModule.forRoot = function (config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: ToastNoAnimationModule_1,\n            providers: [\n                {\n                    provide: TOAST_CONFIG,\n                    useValue: {\n                        default: DefaultNoAnimationsGlobalConfig,\n                        config: config,\n                    },\n                },\n            ],\n        };\n    };\n    var ToastNoAnimationModule_1;\n    ToastNoAnimationModule = ToastNoAnimationModule_1 = __decorate([\n        NgModule({\n            imports: [CommonModule],\n            declarations: [ToastNoAnimation],\n            exports: [ToastNoAnimation],\n            entryComponents: [ToastNoAnimation],\n        })\n    ], ToastNoAnimationModule);\n    return ToastNoAnimationModule;\n}());\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, ComponentPortal, DefaultGlobalConfig, DefaultNoAnimationsGlobalConfig, DefaultNoComponentGlobalConfig, Overlay, OverlayContainer, OverlayRef, TOAST_CONFIG, Toast, ToastContainerDirective, ToastContainerModule, ToastInjector, ToastNoAnimation, ToastNoAnimationModule, ToastPackage, ToastRef, ToastrComponentlessModule, ToastrModule, ToastrService };\n"]}